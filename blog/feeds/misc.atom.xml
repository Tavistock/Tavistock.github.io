<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Travis McNeill</title><link href="/" rel="alternate"></link><link href="/feeds/misc.atom.xml" rel="self"></link><id>/</id><updated>2015-05-20T10:20:00-04:00</updated><entry><title>Intro to CRDTs</title><link href="/intro-to-crdts.html" rel="alternate"></link><updated>2015-05-20T10:20:00-04:00</updated><author><name>Travis McNeill</name></author><id>tag:,2015-05-20:intro-to-crdts.html</id><summary type="html">&lt;p&gt;To begin to understand Conflict-free Replicated Data Types it would be good to first understand why it is that you even need them in the first place and what problem they solve.&lt;/p&gt;
&lt;p&gt;Distributed systems are hard. However understanding your distributed computing problem and the compromises you must make go a long way to conquering whatever project that you are tackling. By asking the right questions you can better understand what it is you are giving up and gaining when you do start making decisions about your project.&lt;/p&gt;
&lt;p&gt;We will ask a rather simple question to get a good understanding the problem area:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In a world plagued by uncertainty, what is truth?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Deny Uncertainty&lt;/h2&gt;
&lt;p&gt;For a non distributed system this is rather easy: truth is whatever your database returns as the answer. You simply query the single source of truth and it responds with the what you are looking for, however it overlooks the uncertainty part of the question. This non distributed system chooses to take the problem of uncertainty and build a monolith. What is wrong with this approach is that eventually the monolith will be crushed by it's own weight. Most of the time the monolith solution is the correct answer to this question but if you want to build a system that is incredibly large you can not just keep stacking chairs on top of each other and expect to arrive at the moon.&lt;/p&gt;
&lt;h2&gt;Coordinate through Uncertainty&lt;/h2&gt;
&lt;p&gt;What happens when you do not want to build a monolith? One approach is to take the idea of single point of truth and apply it too a distributed system. You can take a cluster of computers and make them use Paxos or two-phase-commit to agree upon an ordering of received transactions then then calculate a truth that all the members of the cluster share. This leads to a truth that has a property called strong consistency, at any point in time all the clusters will share a consistent truth if they meet certain conditions. The devil is in the details. This strong consistency comes at the cost of being very expensive and only available to certain types of distributed systems. While your truth will always be perfect you may not be able to access it at any point in time and you may not be able to write to it whenever you feel like it. You may need to know certain things about your distributed system, like how many computers are in your cluster, which in some systems is impossible to tell. And there may be some cases where the semantics of your data type may lead to data being lost in the case of concurrent updates. What you may want to do is change what your definition of truth is in a distributed system.&lt;/p&gt;
&lt;h2&gt;Embrace Uncertainty&lt;/h2&gt;
&lt;p&gt;This leads to what is called weak consistency. Instead of electing a leader and recreating the problems of a single point of truth in a system you just give up on that and make truth be eventually consistent. If you make your construct your truth in such a way that additions (and if you are really careful removals) to it regardless of received order result in a stabilized state you can get rid of the need to have a single ledger that dictates the order of events. This type of truth is called a Conflict-free Replicated Data Type and it may just be the answer to your problem.&lt;/p&gt;
&lt;h2&gt;Three's Company&lt;/h2&gt;
&lt;p&gt;The way it gets to a stable state is by the careful application of mathematical properties. The CRDT must fulfill three properties. If you have truth that can be modified at two places at the same time that once combined result in the same truth you do not need to coordinate. You may remember this from math class, it is called communicative property:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Communicative =&amp;gt; (+ a b) = (+ b a)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The next property is one of total ordering so we do not need a ledger of transactions. Transitioning into a stable state will be guaranteed no matter what order you receive the changes to our truth in. This is called the associative property:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Associative =&amp;gt; (+ a (+ b c)) = (+ (+ a b) c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The final one is called the idempotent property. When performing an operation multiple times it will result in the same state. With this you can receive operations on our truth twice and end up in same state which happens pretty often in distributed programming because of message duplication:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Idempotent =&amp;gt; (+ a a) = a
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Semi-Lattices&lt;/h2&gt;
&lt;p&gt;Luckily for you these are already well known properties in mathematics and together they make up (upper or lower bound) semi-lattices. An example of a semi-lattice is &lt;code&gt;max&lt;/code&gt; on two integers or &lt;code&gt;union&lt;/code&gt; on two sets. When given a list of integers when &lt;code&gt;max&lt;/code&gt; is applied from any starting point (communicative property), on any random order of integers (associative property), and any number of duplicate integers (idempotent property) you will always get the correct &lt;code&gt;max&lt;/code&gt; for that list of integers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;find the max of: [8 9 5 7 1]

        list w/ dupes := 8 9 5 7 1 9        list random order := 5 9 7 1 8
                         \ / \ / \ /                             \ / \ / |
max =&amp;gt;                    9   7   9                               9   7  8
                           \ /  /                                  \ /  /
max =&amp;gt;                      9  9                                    9  8
                             \/                                      \/
max =&amp;gt;                        9                                       9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A same thing applies to sets using the &lt;code&gt;union&lt;/code&gt; operation.&lt;/p&gt;
&lt;h2&gt;A Bad Example&lt;/h2&gt;
&lt;p&gt;But you run into a problem using this as the only basis for creating useful CRDTs. As an example you could construct, merely as an example,  a CRDT that we will call bad-Last-Write-Wins or &lt;code&gt;bad-LWW&lt;/code&gt; that forms a semi-lattice but loses useful bits of your information. For this &lt;code&gt;bad-LWW&lt;/code&gt; we will make the semi-lattice keep the data of the highest wall-clock time-stamp and the operation will be called &lt;code&gt;recent&lt;/code&gt;. Now assuming all the wall-clocks are in sync (which is an impossible assumption for a number of reasons*) whenever we call &lt;code&gt;recent&lt;/code&gt; on two &lt;code&gt;bad-LWW&lt;/code&gt; it will choose the latest. No matter the order a computer in a cluster receives &lt;code&gt;bad-LWW&lt;/code&gt;s and then calls &lt;code&gt;recent&lt;/code&gt; on them it will reach the same truth. If it gets duplicates of the same &lt;code&gt;bad-LWW&lt;/code&gt; it will always reach the same state.&lt;/p&gt;
&lt;p&gt;For this demonstration a &lt;code&gt;bad-LWW&lt;/code&gt; data structure is a tuple of &lt;code&gt;[time-stamp data]&lt;/code&gt; where the time-stamp is an integer n for the seconds after initialization and data is arbitrary data. The operation on the &lt;code&gt;bad-LWW&lt;/code&gt;, &lt;code&gt;recent&lt;/code&gt;, just returns the highest time-stamped tuple. As a diagram like the integers and &lt;code&gt;max&lt;/code&gt; operation it looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;find the most recent of:
             [8 &amp;quot;acd&amp;quot;] [9 &amp;quot;acde&amp;quot;] [5 &amp;quot;ab&amp;quot;] [7 &amp;quot;ac&amp;quot;] [1 &amp;quot;a&amp;quot;]
                 \         /          \      /        |
recent =&amp;gt;         [9 &amp;quot;acde&amp;quot;]         [7 &amp;quot;ac&amp;quot;]     [1 &amp;quot;a&amp;quot;]
                      \            /            /
recent =&amp;gt;               [9 &amp;quot;acde&amp;quot;]      [1 &amp;quot;a&amp;quot;]
                              \          /
recent =&amp;gt;                      [9 &amp;quot;acde&amp;quot;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Needs Improvement&lt;/h2&gt;
&lt;p&gt;Now this &lt;code&gt;bad-LWW&lt;/code&gt; is called this because it does not preserve the semantics of the underlying data structure (it looks like time-stamps 5 and 7 happened concurrently and a bit of truth was lost from the string because of that) nor is the wall-clock time-stamp a viable strategy in a real world system. Now with this simple yet useless CRDT you can further refine it until it is something that is more valuable for real world problems. In the next few blog posts I will talk at first about the different species of known CRDT, then focus on ways of representing sequences in distributed computing, and finally do a deep dive on the implementation of LSEQ, a data structure for representing sequences, in clojure.&lt;/p&gt;</summary><category term="CRDT"></category></entry><entry><title>Markov Poem</title><link href="/markov-poem.html" rel="alternate"></link><updated>2015-04-07T10:20:00-04:00</updated><author><name>Travis McNeill</name></author><id>tag:,2015-04-07:markov-poem.html</id><summary type="html">&lt;p&gt;I had an assignment to make a poem generator for my computer science class but it involved arrays and random choice. I thought I could do a little bit better so I made a markov chain text generator.&lt;/p&gt;
&lt;p&gt;You've probably seen a markov text generator before because everyone and their mother has some gimmick twitter trained off of a humorous combo like &lt;a href="https://twitter.com/kimkierkegaard"&gt;a philosopher and a celebrity&lt;/a&gt; or &lt;a href="https://twitter.com/erowidrecruiter"&gt;drugs and spam&lt;/a&gt;. Mine is going to be a bit simpler.&lt;/p&gt;
&lt;h3&gt;Data Munging&lt;/h3&gt;
&lt;p&gt;First we need to get the data that we are going to train the markov chain off of. I am going to just use flat .txt files that I find on the internet as models for my poems. The data structure I need is a sequential list of strings because the simple markov chain I'm making just needs to know the word it wants and the word after for it's state machine. This doesn't make sense yet but hold on.&lt;/p&gt;
&lt;p&gt;Data munging sounds a bit dirty and urban dictionary seems to think it has something to do with sex however it is simply getting the data we want in the proper format that we want. What I did here was make a simple open url and open file that make a text blobs (without new lines) then make a list of words. The only real reason I'm mentioning this is because when getting the text blob into a list of words I used the powerful and often untaught &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html"&gt;Stream API&lt;/a&gt; in the Java.util standard library. If you are familiar with functional programming this API can make your code more succinct while keeping different concerns separate.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\\W&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
            &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
            &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Collectors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toList&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can read I make a stream out of the text blob split on whitespace characters, then filter it for any empty strings, and finally collect (parallel reduce as far as I can tell) it as a list.&lt;/p&gt;
&lt;h3&gt;Markov Through Structure (aka Data &amp;gt; Functions &amp;gt; Macros)&lt;/h3&gt;
&lt;p&gt;This is where I'm going to throw a lot of information at you. Markov chains can be though of as little machines that make choices. You get into a state and then from that state you transition into another state. This seems like a good way of modeling games or something but it doesn't seem like a good way of making sentences or poems. If you think a little bit obtusely it will all begin to make sense. Make the current word the state and then all words that appear after that word as it's choices. What you can do with this is randomly move from state to choice and then make the next choice the new state. It may not make meaningful sentences(it might make interesting sentences sporadically) but it will make sentences that are more coherent than a pure random approach.&lt;/p&gt;
&lt;p&gt;What we want to do is make our list of words into a data structure that relates state to choices. Luckily this is a rather common problem(trust me you want rather common problems) so there is a solution in Java and pretty much every oter programming language. It is called a HashMap(Dict in python, Map or {} literal in clojure) and I am going to use it to map from a String to a LinkedList of Strings. A saying in Clojure is that data is better than functions is better than macros and here where we could make each state machine a function that chooses a choice it is easier to make a Map that points to choices.
Heres the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;getDict&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;chain&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;chain&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
                &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We take the list and for each of the Strings in the list we add it as a key in the hash map and add the word after it as a new linked list or puch it onto the pre-existing linked list. This is bad in my opinion because we mutate the list when we add to it rather than returning a new list and this can lead to problems when we introduce multi-threading but I have no plans of multi-threading this so whatever. If we are at the first entry in a linked list we can't do anything because we need the last word so we assign the current word as the last word and do nothing else.&lt;/p&gt;
&lt;h3&gt;Running this Infernal Machine&lt;/h3&gt;
&lt;p&gt;Next we need to run this markov chain and we are going to use a random number generator as our engine. What we do is randomly choose a key from the Map(which doesn't support this so we just make a list out of keys and select from that) then randomly choose a string out of the LinkedList and make that the new key for the map until our result list is the length we want it to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;randMarkov&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;keysAsArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;keySet&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="n"&gt;Random&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;keysAsArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nextInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keysAsArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;()));&lt;/span&gt;

    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;concat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nextInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;()));&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;concat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Putting it All Together&lt;/h3&gt;
&lt;p&gt;Seeing as how I made my API out of normal functions I just sort of stitch them together to get them to do what I want:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;https://raw.githubusercontent.com&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;/lspector/clojinc/master/Jabberwocky.txt&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;randMarkov&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getDict&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getURL&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;))),&lt;/span&gt;&lt;span class="mi"&gt;140&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This would look a lot better if I made a thread and thrush function in Java like I have in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;address&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;https://raw.githubusercontent.com/lspector/clojinc/master/Jabberwocky.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;address&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;getUrl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;getDict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randMarkov&lt;/span&gt; &lt;span class="mi"&gt;140&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I made a getURL and getFile command that just get the text blob from the file system or from the internet.&lt;/p&gt;</summary><category term="clojure"></category><category term="java"></category></entry></feed>